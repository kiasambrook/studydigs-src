"use strict";
/**
 * Launches phpCs and returns results as JSON
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const util_1 = require("util");
const child_process_1 = require("child_process");
const assert = __importStar(require("assert"));
const execAsync = util_1.promisify(child_process_1.exec);
const EXECUTABLE_VERSIONS = new Map();
const DEFAULT_EXECUTABLE_PATH = path.resolve(__dirname, '../node_modules/php_codesniffer_master/bin/phpcs');
const DEFAULT_OPTIONS = {
    encoding: 'UTF-8',
    standard: 'PEAR',
};
/**
 * Launches phpCs and returns current version
 */
async function version(executablePath = DEFAULT_EXECUTABLE_PATH) {
    var _a, _b;
    if (EXECUTABLE_VERSIONS.has(executablePath))
        return EXECUTABLE_VERSIONS.get(executablePath);
    const { stdout } = await execAsync(`${executablePath} --version`, {
        windowsHide: true,
        timeout: 5000,
    });
    const ver = (_b = (_a = /^PHP_CodeSniffer version (?<ver>\d+\.\d+\.\d+)/i.exec(stdout.trim())) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.ver;
    if (!ver)
        throw new ReferenceError(`Unknown version or invalid executable of phpcs, returned: "${stdout}"`);
    EXECUTABLE_VERSIONS.set(executablePath, ver);
    return ver;
}
exports.version = version;
async function lint(filenames, executablePath = DEFAULT_EXECUTABLE_PATH, options = DEFAULT_OPTIONS) {
    var _a, _b;
    try {
        const ver = await version(executablePath);
        assert.ok(ver >= '2.6', `This library requires phpcs version 2.6 or later, received ${ver}`);
        // we use promisified version, so, should not set exit code or it will throw
        const args = [
            '--report=json',
            '-q',
            `--encoding=${options.encoding}`,
            `--standard=${options.standard}`,
            '--runtime-set ignore_errors_on_exit 1',
            '--runtime-set ignore_warnings_on_exit 1',
        ];
        const { stdout } = await execAsync(`${executablePath} ${args.join(' ')} ${Array.isArray(filenames) ? filenames.join(' ') : filenames}`, {
            windowsHide: true,
            timeout: 15000,
        });
        return JSON.parse(stdout);
    }
    catch (err) {
        if ('stdout' in err) {
            // Determine whether we have an error in stdout.
            const error = (_b = (_a = /^ERROR:\s?(?<error>.*)/i.exec(err.stdout)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.error;
            if (error)
                throw new Error(error.trim());
        }
        throw err;
    }
}
exports.lint = lint;
//# sourceMappingURL=linter.js.map